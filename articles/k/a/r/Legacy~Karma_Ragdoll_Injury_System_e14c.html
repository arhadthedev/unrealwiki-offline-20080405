<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<!-- headlinks removed -->
	<link rel="shortcut icon" href="../../../../misc/uewiki-favicon.png"/>
    <title>Legacy:Karma Ragdoll Injury System - Unreal Wiki</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../../skins/offline/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/md5.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/utf8.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/lookup.js"></script>
    <script type="text/javascript" src="../../../../articles/-/_/_/-.html"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../../articles/c/o/m/MediaWiki%7ECommon.css_d42e.html";
@import "../../../../articles/m/o/n/MediaWiki%7EMonobook.css_fb19.html";
@import "../../../../articles/-/_/_/-.html";
/*]]>*/</style>          </head>
  <body
    class="ns-100">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">Legacy:Karma Ragdoll Injury System</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Unreal Wiki, The Unreal Engine Documentation Site</h3>
	    <div id="contentSub"></div>
	    	    	    <!-- start content -->
	    <p><b>Note to reader:</b> This page represents an incomplete <i>investigation</i> into switching players' pawns into and out of ragdoll mode. Some considerable mileage was made but the implementation does not work in network play.</p>
<hr />
<p>(Note: this text cut from <a href="../../../../articles/k/a/r/Legacy%7EKarma_Ragdoll_3760.html" title="Legacy:Karma Ragdoll">Karma Ragdoll</a>. Karma Ragdoll should be definition and description. All these ideas deserve their own page).</p>
<p>This is an idea first proposed on the Wiki by Soldat. Essentially, the idea is that when a player is damaged by a weapon, they will go into Karma Ragdoll mode for a brief period, depending on the severity of the hit, and then get back up. So, for instance, a hit from an assault rifle may merely cause you to stumble for a split second before regaining control while a direct hit from a rocket would send you through the air to end up as a heap on the ground, which (if still alive) would then attempt to crawl back up onto its feet. Soldat came up with the following function which will activate the Ragdoll Physics on a Pawn. It needs to be placed in a subclass of Pawn or called on the Pawn externally (it would require some modification to do that, but could be modified to work in a mutators' damage modification function):</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw6">exec</span> <span class="kw5">function</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> KarmaParamsSkel SkelParams;
  <span class="kw5">local</span> <span class="kw4">String</span> RagSkelName;
 
  RagSkelName = Species.<span class="kw6">static</span>.<span class="me1">GetRagSkelName</span><span class="br0">(</span>GetMeshName<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
  KMakeRagdollAvailable<span class="br0">(</span><span class="br0">)</span>;                                    <span class="co1">// allocate a space for the incoming ragdoll</span>
 
  skelParams = KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>;                      <span class="co1">// create a new skelParams object based off current KParams</span>
  skelParams.<span class="me1">KSkeleton</span> = RagSkelName;                         <span class="co1">// with our new ragdoll</span>
  KParams = skelParams;                                       <span class="co1">// and now, voila! KParams is the new skelParams</span>
 
  KSetBlockKarma<span class="br0">(</span><span class="kw9">true</span><span class="br0">)</span>;                                       <span class="co1">// without this line, I fall THROUGH the floor... gross</span>
 
  SetPhysics<span class="br0">(</span>PHYS_KarmaRagdoll<span class="br0">)</span>;                              <span class="co1">// actually create the ragdoll</span>
<span class="br0">}</span>
</pre></div>
<p>While a neat system, and easy enough to get implemented mostly, it has run into a slight problem: neither Soldat nor myself (I am also trying to implement this, though slightly differently, for my mod) has been able to find a "perfect" way to get the player to get back up after becoming a ragdoll. I have merged our attempts into a single list and described why each did not work quite as planned:</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking"><span class="tocnumber">1</span> <span class="toctext">Removing the Actors Skeleton/Resetting the Karma Parameters, and changing Physics back to PHYS_Walking</span></a></li>
<li class="toclevel-1"><a href="#Freezing_the_Ragdoll"><span class="tocnumber">2</span> <span class="toctext">Freezing the Ragdoll</span></a></li>
<li class="toclevel-1"><a href="#Spawn_a_New_Pawn_above_the_Ragdoll"><span class="tocnumber">3</span> <span class="toctext">Spawn a New Pawn above the Ragdoll</span></a></li>
<li class="toclevel-1"><a href="#Animating_a_Ragdoll"><span class="tocnumber">4</span> <span class="toctext">Animating a Ragdoll</span></a></li>
<li class="toclevel-1"><a href="#Discussion"><span class="tocnumber">5</span> <span class="toctext">Discussion</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking" id="Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking"></a></p>
<h4><span class="mw-headline">Removing the Actors Skeleton/Resetting the Karma Parameters, and changing Physics back to PHYS_Walking</span></h4>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw6">exec</span> <span class="kw5">function</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>.<span class="me1">KSkeleton</span> = <span class="st0">""</span>;
 
        SetPhysics<span class="br0">(</span>PHYS_Walking<span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">exec</span> <span class="kw5">function</span> UnKarmaMe2<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        KParams = <span class="kw1">default</span>.<span class="me1">KParams</span>;
 
        SetPhysics<span class="br0">(</span>PHYS_Walking<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<p>Though in effect the same thing (Removing the Skeleton and Setting the Karma Parameters back to default) it was worth trying both. Neither had any effect. When the physics was set back to PHYS_Walking, the player fell through the floor and out of the world. This was later found to be a result of Karma Ragdoll simulation disabling the regular physics' collision in order to use its own. Setting bCollideWorld to true when you set the physics back to PHYS_Walking will prevent the player from falling through the floor, but it still won't get back up or do anything except look around and shoot. (Because its "state" hasn't changed in the Pawn class, it still thinks it's walking.) However, no animations will play and it will not move anywhere.</p>
<p><a name="Freezing_the_Ragdoll" id="Freezing_the_Ragdoll"></a></p>
<h4><span class="mw-headline">Freezing the Ragdoll</span></h4>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw6">exec</span> <span class="kw5">function</span> UnKarmaMe3<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        KFreezeRagdoll<span class="br0">(</span><span class="br0">)</span>;
 
        SetPhysics<span class="br0">(</span>PHYS_Walking<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<p>This was tried by Soldat and caused the ragdoll to freeze. Aside from not falling into the floor, this was no more successful than removing the skeleton.</p>
<p><a name="Spawn_a_New_Pawn_above_the_Ragdoll" id="Spawn_a_New_Pawn_above_the_Ragdoll"></a></p>
<h4><span class="mw-headline">Spawn a New Pawn above the Ragdoll</span></h4>
<p>Soldat's initial idea was to simply destroy the ragdoll and spawn a new pawn on top of where the ragdoll used to be. The problem with this, was that it would telefrag anyone the ragdoll fell under. Another problem was that it didn't have a cool animation to show the person getting back up.&#160;:P The telefragging was solved with a suggestion from Mysterial and expanded by CheshireCat to disable the collision on the new pawn until it was no longer touching anyone else, then reenable it. The only existing problem with this method is that there is no real smooth way of showing the player get back up. As I understand, this is the current method that Soldat is experimenting with.</p>
<p><a name="Animating_a_Ragdoll" id="Animating_a_Ragdoll"></a></p>
<h3><span class="mw-headline">Animating a Ragdoll</span></h3>
<p>A short study revealed that merely setting the Physics to PHYS_KarmaRagdoll with cause serious problems with animation and will prevent any animations from being played, even if physics is reset to PHYS_Walking immediately after the call to change it to PHYS_KarmaRagdoll. In other words, the pawn does not have to spend any time being a ragdoll to cause this effect. I am still researching this find out a way to get animations to work after returning the physics to normal. Soldat (I believe) is using the last method detailed above (making a new pawn to replace the old one) and is trying to find a way to make it look like the new pawn is actually the old pawn getting up.</p>
<p><a name="Discussion" id="Discussion"></a></p>
<h2><span class="mw-headline">Discussion</span></h2>
<p><b>Foxpaw:</b> This page has been mainly refactored from Words About Karma Ragdoll Deaths along with some stuff I wrote myself. Credit for all of the ideas provided has been given to their respective authors, I believe. I hope I didn't leave anyone out. By the way, Soldat, I had an idea - you may be able to set the person to a crouching idle animation and tween to a standing animation, then, you could make it so when the player lands flat on the ground, it kicks up a dust cloud or something like that, that would obscure the jump from lying down to the crouching position. Let me know how that turns out if you try it, I'm going to continue working on a way to get the original pawn to move again.</p>
<p><b>Foxpaw:</b> Eureka! I've gotten the thing to animate again after returning from ragdoll mode. It wipes out the current position and replaces it with the default but at least it doesn't require spawning a new pawn and moving over all of the health, etc. from it. All you have to do is change the mesh. So basically, call something like the following:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="co1">// Reenables animations after returning from Karma Ragdoll simulation. Requires a global</span>
<span class="co1">// variable SafeMesh, which is a mesh object which we can be guaranteed that this object</span>
<span class="co1">// is not. If we try to do this with the same mesh that we are it will not work, therefore,</span>
<span class="co1">// it is imperative that a player never be the mesh stored in safemesh. An alternative</span>
<span class="co1">// is to have two "safe meshes" and check to see if the players mesh == the first safemesh,</span>
<span class="co1">// if so use the second safemesh. Otherwise just use the first. This function assumes a</span>
<span class="co1">// safemesh that is guaranteed to never be what the player is set to.</span>
<span class="kw5">function</span> ReinitializeMesh<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> Mesh OldMesh;
 
  OldMesh = Mesh;
  LinkMesh<span class="br0">(</span> SafeMesh <span class="br0">)</span>;
  LinkMesh<span class="br0">(</span> OldMesh <span class="br0">)</span>;
 
  <span class="kw1">return</span>;
<span class="br0">}</span>
</pre></div>
<p>I also noticed that you must be careful to not engage the ragdoll simulation for too short of a time. When ragdoll simulation first begins, your limbs are all concentrated in one spot and they spread out until they are in the correct position. This takes only a fraction of a second, though it may vary on different computers. If you try to use the karma injury system for something mild like a glancing blow that just moves you for a split second it will make you turn into a ball of limbs instead!</p>
<p><b>Foxpaw:</b> I noticed a small problem, but it may be solveable by a bit of number fudging. The momentum imparted by various weapons varies immensely. Assault Rifle and Lightning gun are only 1, minigun is 1200, each flak shard is 10000, rockets are 50000, shock gun primary 60000, flak grenades 75000, and the shock combo in excess of 130000. The problem, here, of course, is if I set it up so that a rocket puts him down for 3 seconds, he's out like a light if he gets hit by a shock combo. If, however, it's set so that a shock combo merely keeps him out for 5 seconds, the minigun/AR/lightning gun do diddly squat. Aside from the fact that you have to wait a while for the target to recover, it's pretty fun. I did notice a couple of things though: A) your ragdoll assumes you were standing. Getting ragdolled while crouching does not produce the same effect. B) Ragdolls have a tendancy to "fall through" very thin surfaces. (IE A 'grate' over a pit of slime) Though cool, the pawn gets stuck when it recovers. This occurs with my "pawns", regular pawns may act differently.</p>
<p><b>Chema:</b> Great! and... weird!! I had been trying the UnKarma stuff for a few days. I also got stuck by the animation. Here is a full (I think) UnKarmaMe(), incluiding the double mesh link:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw6">exec</span> <span class="kw5">function</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw5">local</span> Mesh OldMesh;
 
        SetPhysics<span class="br0">(</span>PHYS_Walking<span class="br0">)</span>;     <span class="co1">// Reset physics</span>
        bCollideWorld = <span class="kw9">true</span>;          <span class="co1">// And world collision</span>
                                                                <span class="co1">// (KActors use       KSetBlockKarma for that)</span>
        SetCollision<span class="br0">(</span><span class="kw9">true</span>, <span class="kw9">true</span> , <span class="kw9">true</span><span class="br0">)</span>; <span class="co1">// Block actors and players again</span>
 
        OldMesh = Mesh;
        LinkMesh<span class="br0">(</span> SafeMesh <span class="br0">)</span>;         <span class="co1">// Global mesh, you will not see it</span>
        LinkMesh<span class="br0">(</span> OldMesh <span class="br0">)</span>;          <span class="co1">// This puts your mesh back</span>
<span class="br0">}</span>
</pre></div>
<p>The doble mesh link is really weird, but works. And it is dificult to find what to do whit all those native functions, wich we don't have an idea what really do.</p>
<p>Now, to fix the abrupt standing, we could try an immediate crouch, or better, I saw somewhere a function to initialize the mesh anim before spawn.</p>
<p><b>Foxpaw:</b> My pawn comes up in the crouching position. It was as simple as adding PlayAnim( 'Crouch' ); after you relink the oldmesh. (I'm pretty sure that those parameters are optional. I use a wrapper for animation with my "pawns," so my syntax is slightly different.)The real problem is not the starting animation, but how to get the starting animation to be something very close to what the ragdoll was using, I think. I have had ragdolls get their foot caught in tiles on the floor and not end up falling over, just kind of going limp - in that instance the standing is better. I've been experimenting the the dark magic of manual skeleton rotation - I have a hunch but I'm not quite sure how I'll go about it. If you could read the rotation of all of the bones, you could manually set them after relinking the mesh and then from there tween to an animation. However, obtaining the bones rotation is not as simple as calling the GetBoneRotation, as that only returns the rotation relative to where the current animation says that it should be. Bones seem to use a haphazard mix of absolute and relative locations and rotations, as well as even having their own internal coordinate system for each bone! For that reason it's a bit confusing. <a href="../../../../articles/s/k/e/Legacy%7ESkeletal_Mesh_3f4a.html" title="Legacy:Skeletal Mesh">Skeletal Mesh</a> has a listing of skeletal animation functions and a short description of those that I have experimented with. Unforunately, I haven't played with all of the parameters of the functions. There's another interesting thing that should be considered, but maybe this is only a problem with the juggernaut skeleton that I'm using: The juggernaut skeleton has an overwhelming tendancy to fall to its knees, then fall flat to its face. This may be because of the limits on the bones though. It generally performs this if hit by a "singular, direct" type of attack, like a direct hit from rocket, shock rifle, etc. Multiple-hit type weapons like flak work fine, and if a rocket hits the ground nearby the results are believable. One more thing. My pawns don't have this problem because of the way that they are scripted, but the built in pawns suffer a set amount of impulse whenever they get hit as a ragdoll. It does not use the actual momentum of the gun, and I don't think it applies it to the actual bone hit either. The following is a slighly modified excerpt from the code I use (the code I use is in an else block and has an argument Bone instead of declaring it.)</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw5">local</span> <span class="kw4">float</span> Dummy; <span class="co1">// Just to satisfy an out argument.</span>
  <span class="kw5">local</span> <span class="kw4">name</span> Bone;
 
  <span class="kw1">if</span> <span class="br0">(</span> Physics == PHYS_KarmaRagdoll <span class="br0">)</span>
  <span class="br0">{</span>
    Bone = GetClosestBone<span class="br0">(</span> HitLocation, Normal<span class="br0">(</span>Momentum<span class="br0">)</span>, Dummy <span class="br0">)</span>;
    KAddImpulse<span class="br0">(</span>momentum, hitlocation, Bone<span class="br0">)</span>;
  <span class="br0">}</span>
 
  <span class="co1">// If you wanted you could collapse this to take up less space you could also just do:</span>
  <span class="kw5">local</span> <span class="kw4">float</span> Dummy; <span class="co1">// Just to satisfy an out argument.</span>
 
  <span class="kw1">if</span> <span class="br0">(</span> Physics == PHYS_KarmaRagdoll <span class="br0">)</span>
    KAddImpulse<span class="br0">(</span>momentum, hitlocation, GetClosestBone<span class="br0">(</span> HitLocation, Normal<span class="br0">(</span>Momentum<span class="br0">)</span>, Dummy <span class="br0">)</span><span class="br0">)</span>;
</pre></div>
<p>I have no idea why Digital Extremes used that RagSkelVel and SkelParams.KShotStrength nonsense. This looks way more ragdollish and much cooler as it allows for multiple sources of force to be acting in rapid succession. IE when you get nailed at close range with the flak cannon. (Of course you probrably wouldn't survive anyways but maybe if you had lots of shields and health)</p>
<p><b>Foxpaw:</b> I got the getting up part a bit better. Your position on the ground is now recreated once the mesh is reset, but only on key bones. So now I'm a running dilapitated pile of crumpled up bones.&#160;:P I'll try to find an efficient way to tween out the dilapitatedness into normal movement.</p>
<p><b>Chema:</b> Houston, I can get up... but can't crouch!</p>
<p>Adding PlayAnim( 'Crouch' ); to UnKarmaMe doesn't work. Actually, it works normally, but not when I'm Karmed: I stand up, but don't crouch. If I call UnKarmaMe again, from console, then it works. Simply put: I can't animate the mesh in the same call that UnKarmaMe, no matter if I put in a different function.</p>
<p>Any idea whats wrong with me? And with my code? (hehe). Are you doing anything special apart of the stuff in the previous UnKarmaMe()? I'm setting my TestxPawn trough the URL (dm-gael?Game=Test.TestGame?Class=Test.TestxPawn), but there should be a scripted way to do it for a game. An equivalent of the CheckReplacement of the Mutators? (Thanks for all your help!)</p>
<p><b>Foxpaw:</b> It may be that the animation won't play on the same call. As you may have noticed, (maybe, it's kind of hard to see.) For a short time after becoming a ragdoll you are just a ball of concentrated body parts. It is possible that your ragdollness persists until the next tick. Or something. The 'personnell' on my mod are completely custom - I've written my own classes for everything below actor, because Pawns have lots of built in junk.&#160;:P It has an attached "Mesh Controller" which monitors animation, etc. and would play the idling animation the next opportunity it got... so if it cannot indeed be called from the same function it would try again the next tick. That may be why mine goes back to the idling animation while yours requires a second call. I believe that you can use checkreplacement in mutators to replace your xpawn with the one you have made.. I haven't tested it but I believe that you can because I think that checkreplacement is called from within spawn, before the controller would make its Possess call, which I believe does not occur until after the spawn has returned. I haven't tested that part out, the order that the controller stuff goes in because I just wrap the controller class, so I don't really use it for anything.</p>
<p><b>Foxpaw:</b> I noticed another thing, but it might not be a big deal for your application. If you really clobber a ragdoll sometimes it will suffer a simerror as a result of its joints being spun so fast. This will, by default, result in it being destroyed - definately a bad thing if the player was merely injured! You can set bDestroyOnSimError in its KParams to prevent this, but it doesn't protect against everything. bKImportantRagdoll (maybe doesn't have a K, I don't remember for sure) might also be good because it prevents the ragdoll from being destroyed if the system runs low on memory and wants to make a new ragdoll. The simerror thing may not apply in your application, because generally that will only result from things such as flak to the head at point blank or similar events, which would kill the pawn anyway. It might also be worth investigating what effects mutators that affect the ragdolls will have. I'm not sure about Floaty Cadavers, but I know that Slow Motion Corpses works by slowing down the entire Karma Ragdoll simulation system. This would slow down injured players as well. I don't know if that's a problem or not, but it's worth checking out.</p>
<p><b>OBWANDO:</b> I took a few hours fighting with this, and it wouldnt work at all in any way. Heres what I found... If you want to get the pawns to go back to their original animated mesh, you need to link with another VALID different mesh. If you try to link with a null or non-specified mesh, it will simply not link at all which then you will wind up linking the original named mesh and that does absolutely nothing. In the end heres what seemed to work for me:</p>
<p>In my pawn class (RBxPawn.uc):</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw5">var</span>    <span class="br0">(</span><span class="kw6">Global</span><span class="br0">)</span> mesh SafeMesh;
 
<span class="kw6">exec</span> <span class="kw5">function</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> KarmaParamsSkel SkelParams;
  <span class="kw5">local</span> <span class="kw4">String</span> RagSkelName;
 
  SafeMesh = Mesh;                                            <span class="co1">// This is where I am getting the pawn's original mesh</span>
  RagSkelName = Species.<span class="kw6">static</span>.<span class="me1">GetRagSkelName</span><span class="br0">(</span>GetMeshName<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
  KMakeRagdollAvailable<span class="br0">(</span><span class="br0">)</span>;                                    <span class="co1">// allocate a space for the incoming ragdoll</span>
 
  skelParams = KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>;                      <span class="co1">// create a new skelParams object based off current KParams</span>
  skelParams.<span class="me1">KSkeleton</span> = RagSkelName;                         <span class="co1">// with our new ragdoll</span>
  KParams = skelParams;                                       <span class="co1">// and now, voila! KParams is the new skelParams</span>
 
  KSetBlockKarma<span class="br0">(</span><span class="kw9">true</span><span class="br0">)</span>;                                        <span class="co1">// without this line, I fall THROUGH the floor... gross</span>
 
  SetPhysics<span class="br0">(</span>PHYS_KarmaRagdoll<span class="br0">)</span>;                              <span class="co1">// actually create the ragdoll</span>
<span class="br0">}</span>
 
<span class="kw6">exec</span> <span class="kw5">function</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>.<span class="me1">KSkeleton</span> = <span class="st0">""</span>;
 
  SetPhysics<span class="br0">(</span>PHYS_Walking<span class="br0">)</span>;        <span class="co1">// Reset physics</span>
  bCollideWorld = <span class="kw9">true</span>;            <span class="co1">// And world collision</span>
                                         <span class="co1">// (KActors use KSetBlockKarma for that)</span>
  SetCollision<span class="br0">(</span><span class="kw9">true</span>, <span class="kw9">true</span> , <span class="kw9">true</span><span class="br0">)</span>; <span class="co1">// Block actors and players again</span>
 
  LinkMesh<span class="br0">(</span> SkeletalMesh<span class="st0">'Weapons.AssaultRifle_1st'</span> <span class="br0">)</span>;  <span class="co1">// I am using a valid mesh which is not the same as the pawn's original mesh</span>
                                   <span class="co1">// You should probably use a precached mesh for performance reasons, the gun seemed good here</span>
  LinkMesh<span class="br0">(</span> SafeMesh <span class="br0">)</span>;                <span class="co1">// Link the pawn's original mesh and we're done!</span>
<span class="br0">}</span>
</pre></div>
<p><b>Foxpaw:</b> I believe that is the same as what I wrote above. SafeMesh DOES need to be defined as a mesh, I guess I should have explicitly stated that. The OldMesh is the mesh that we want to return to and is read in the unkarmatize function on my "livingthing" class. (This is the "livingthing" equivalent of the unkarmame function.) I could have sworn we discussed the idea of using two safemeshes in case, for whatever reason, the pawn was using one of those meshes, I don't see that anywhere on this page though so maybe I just imagined it.&#160;:P Should we remove the failed attempts listed above or leave them so others can learn that those methods don't work and why the didn't work?</p>
<p><b>OBWANDO:</b> I would say leave it in place, it shows the evolution of the learning curve to a final conclusion. You did mention (or i assumed) that there were 2 safemeshes, but I did not know that 1 had to be explicitly defined, and that was what threw me, and could others. I wouldn't have made it this far without everything being available to read.</p>
<p><b>Foxpaw:</b> Okay. Both safemeshes would actually need to be defined, but you can usually get away with using just one, depending on the application. In this instance it's highly unlikely that a pawn would have a first person weapon mesh as their mesh so you could get away with the way you did it.</p>
<p><b>Foxpaw:</b> I've noticed one small issue but it's not that big of a deal. If you rotate bones using Unrealscript, the karma ragdoll is not rotated appropriately. The visual representation of it is, but the actual collision/simulation information remains unchanged. That's probrably not a big issue, I've been experimenting with rotating bones to have the player "get back up" from whatever position they ended up in. In this instance, the simulation can be slightly innaccurate if you are hit again while getting up.</p>
<p><b>Foxpaw:</b> I almost forgot - there's a big problem with this code, but it might not be that hard to work around. There's a limit on the number of ragdolls that you can have in play at any time. I believe it may be per zone, however. The limit appears to be rather low, unfortunately, approximately 3 ragdolls per zone. If you had two carcasses and two injured players, one would be denied a ragdoll and would just stand still. You could work around this by using the IsRagdollAvailible, and if one is not the player could just play some other injury animation and be simulated using regular physics.</p>
<p><b>OBWANDO:</b> I agree, I listed a piece of simple code to get the idea, but to prevent the problems from occuring here is a small snip that you could use as well to combat the problems of unavailability.</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw6">exec</span> <span class="kw5">function</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> KarmaParamsSkel SkelParams;
  <span class="kw5">local</span> <span class="kw4">String</span> RagSkelName;
 
  SafeMesh = Mesh;                                            <span class="co1">// This is where I am getting the pawn's original mesh</span>
 
  <span class="kw1">if</span><span class="br0">(</span> RagdollOverride != <span class="st0">""</span><span class="br0">)</span>                                  <span class="co1">// Try to get the rag-doll setup.</span>
        RagSkelName = RagdollOverride;                        <span class="co1">// If there is an override, use it first</span>
  <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>Species != <span class="kw9">None</span><span class="br0">)</span>                                    <span class="co1">// if not, use species.</span>
        RagSkelName = Species.<span class="kw6">static</span>.<span class="me1">GetRagSkelName</span><span class="br0">(</span> GetMeshName<span class="br0">(</span><span class="br0">)</span> <span class="br0">)</span>;
 
  <span class="kw1">if</span><span class="br0">(</span> RagSkelName != <span class="st0">""</span> <span class="br0">)</span>                                         <span class="co1">// If we did find one, try to allocate the space.</span>
  <span class="br0">{</span>
        KMakeRagdollAvailable<span class="br0">(</span><span class="br0">)</span>;                                  <span class="co1">// allocate a space for the incoming ragdoll</span>
  <span class="br0">}</span>
 
  <span class="kw1">if</span><span class="br0">(</span> KIsRagdollAvailable<span class="br0">(</span><span class="br0">)</span> &amp;&amp; RagSkelName != <span class="st0">""</span> <span class="br0">)</span>
  <span class="br0">{</span>  
    skelParams = KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>;                    <span class="co1">// create a new skelParams object based off current KParams</span>
    skelParams.<span class="me1">KSkeleton</span> = RagSkelName;                       <span class="co1">// with our new ragdoll</span>
    KParams = skelParams;                                     <span class="co1">// and now, voila! KParams is the new skelParams</span>
 
    KSetBlockKarma<span class="br0">(</span><span class="kw9">true</span><span class="br0">)</span>;                                     <span class="co1">// without this line, I fall THROUGH the floor... gross</span>
 
    SetPhysics<span class="br0">(</span>PHYS_KarmaRagdoll<span class="br0">)</span>;                            <span class="co1">// actually create the ragdoll</span>
  <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p><b>OBWANDO:</b> One thing I have noticed that that you can crash the client pretty easily if you try to do this in a dedicated network mode. On a local client there are no problems, but from what I have seen, a dedicated server will not allow the physics to change to ragdoll, so your client will show a ragdoll, but your server will still show the last known physics mode (like PHYS_Walking, or PHYS_Falling). Maybe we should look at starting a thread or page on network implementation.</p>
<p><b>Foxpaw:</b> I don't understand what you mean by that.. how do you mean the server will "show" the last known physics mode, if it is a dedicated server? The server/client problem you are having is likely due to the KarmaMe function not being replicated.. or something like that. I haven't tested mine over network yet but it is set to be triggered when hit, if the imparted momentum is over a certain threshold. I am not sure how the autonomous proxy treats exec functions so the problem could be with that. If you want to ensure that the ragdolling is consistant on both client and server you could have a boolean variable that is replicated reliably from server to client, and a check in tick - if the variable is true and we are not in PHYS_KarmaRagdoll, then call the KarmaMe function, if the variable is false and we are in PHYS_KarmaRagdoll, then call the UnKarmaMe function. This, of course, would require those functions split into two pieces because you wouldn't want to call an exec function and have the cause the server to request that same function to be called on the client, which would then cause the server to request that same function to be called on the client again, etc. Enough talk!&#160;:P The implementation could be something like this: (I didn't actually compile and test this, there could be typos. It would also maybe need some tweaking to allow for running out of ragdolls. You could use a timer or whatever you want for unkarmame. I use a manually implemented timer in tick.)</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw5">var</span> <span class="kw4">bool</span> bIsRagdolling;
<span class="kw5">var</span> <span class="kw4">float</span> RagdollThreshold;
 
<span class="kw1">replication</span>
<span class="br0">{</span>
  <span class="kw6">reliable</span> <span class="kw1">if</span> <span class="br0">(</span> <span class="kw8">ROLE</span>==<span class="kw9">ROLE_Authority</span> <span class="br0">)</span>
    bIsRagdolling;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> TakeDamage<span class="br0">(</span><span class="kw4">int</span> Damage, <a href="/Pawn"><span class="kw10">Pawn</span></a> Instigator, <span class="kw4">Vector</span> HitLocation, <span class="kw4">Vector</span> Momentum, class&lt;DamageType&gt; <a href="/DamageType"><span class="kw10">DamageType</span></a><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw6">Super</span>.<span class="me1">TakeDamage</span><span class="br0">(</span>Damage, Instigator, HitLocation, Momentum, <a href="/DamageType"><span class="kw10">DamageType</span></a><span class="br0">)</span>;
  <span class="kw1">if</span> <span class="br0">(</span><span class="kw8">Role</span> == <span class="kw9">ROLE_Authority</span> &amp;&amp; VSize<span class="br0">(</span>Momentum<span class="br0">)</span> &gt; RagdollThreshold<span class="br0">)</span>
    bIsRagdolling = <span class="kw9">true</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw8">Tick</span><span class="br0">(</span><span class="kw4">float</span> DeltaTime<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw6">Super</span>.<span class="kw8">Tick</span><span class="br0">(</span>DeltaTime<span class="br0">)</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span><span class="kw8">Role</span> &lt; <span class="kw9">ROLE_Authority</span><span class="br0">)</span>
    <span class="kw1">if</span> <span class="br0">(</span>bIsRagdolling &amp;&amp; Physics != PHYS_KarmaRagdoll<span class="br0">)</span>
      KarmaMe<span class="br0">(</span><span class="br0">)</span>;
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>!bIsRagdolling &amp;&amp; Physics == PHYS_KarmaRagdoll<span class="br0">)</span>
      UnKarmaMe<span class="br0">(</span><span class="br0">)</span>;
<span class="br0">}</span>
 
 
<span class="kw6">simulated</span> <span class="kw5">function</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Do your karmame stuff here.</span>
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Do your unkarmame stuff here.</span>
<span class="br0">}</span>
</pre></div>
<p><b>OBWANDO:</b> Heres what I've seen. In most of the Epic code, you will see that they have the karma sequences set up so that the server's pawn doesnt actually get its physics set into KarmaRagdoll mode (Level.NetMode&#160;!= NM_DedicatedServer). Only the client does. Now this may seem simple in theory, but the reality is that if you touch a floor surface, or its a bot (or a player) that jumps then the physics on the server will change and as a result the physics from the server will be replicated as part of the normal parent class replication to that physics mode. Thats where the problems begin since on the client you are in KarmaRagdoll, and the server replicates a PHYS_Walking, or whatever, but its not Ragdoll, so the client crashes since you cannot have a walking pawn that is in PHYS_KarmaRagdoll. This means you have to address the problem to prevent the client from getting the physics change unless you have restored the physics and mesh back and are ready for that PHYS mode.</p>
<p><b>Foxpaw:</b> Ah, yes. The ragdolls aren't simulated on the server usually because that just wastes resources. They are "torn off" when they are created, so they cease to replicate. I think that the implementation I listed above should work.. I hope. I haven't tested that or played around with it, I don't really know all of the nuances of the pawn class since I don't use it for anything, but it seems logical.</p>
<p><b>Foxpaw:</b> Apparently, the limit placed on ragdolls is optional. If you just remove the MakeRagdollAvailible part and the IsRagdollAvailible check, you can apparently make as many ragdolls as you want. Finally, my battlefields can have carcasses littered all around, instead of that stupid de-res thing.&#160;:P</p>
<p><b>PlaneGuy:</b> I tried the MP ragdoll code above, but it still crashes. I was thinking if being ragdolled is a state, you can set the pawn to ignore any non-ragdoll/karma related action in that state. Thoughts?</p>
<p><b>OBWANDO:</b> Here is the code I created that successfully works. I used a manual timer since the SetTimer was too flaky for me. The server first of all is the only one that will REALLY know what mode our client is supposed to be in. When we are ragdolling, we should probably prevent the bots from moving the ragdoll, or when we come back out, the client will show the pawn pretty far away from where it should have been. and most importantly, we need to make sure the client does not try to change the physics via update from the server.</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw5">var</span> <span class="kw4">bool</span> bKarma; <span class="co1">// server paramater to client if you need to be set to karma mode</span>
<span class="kw5">var</span> <span class="kw4">bool</span> bInKarma; <span class="co1">// server parameter letting the client know to override any physics changes to karma.</span>
<span class="kw5">var</span> <span class="kw4">bool</span> bTickMe; <span class="co1">// my tick timer boolean</span>
<span class="kw5">var</span> <span class="kw4">bool</span> bClKarma; <span class="co1">// the client flag that lets us know that the client is indeed in karma mode. (remember Physics will be changed from replication)</span>
<span class="kw5">var</span> <span class="kw4">int</span>       iTickTime; <span class="co1">// a timer counter since SetTimer was too flaky to use over network.</span>
 
<span class="kw1">replication</span>
<span class="br0">{</span>
        <span class="kw6">reliable</span> <span class="kw1">if</span> <span class="br0">(</span><span class="kw8">Role</span> == <span class="kw9">ROLE_Authority</span> <span class="br0">)</span>
                bKarma, bInKarma;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">event</span> PostNetReceive<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span> PlayerReplicationInfo != <span class="kw9">None</span> <span class="br0">)</span>
    <span class="br0">{</span>
                Setup<span class="br0">(</span><span class="kw5">class</span><span class="st0">'xUtil'</span>.<span class="kw6">static</span>.<span class="me1">FindPlayerRecord</span><span class="br0">(</span>PlayerReplicationInfo.<span class="me1">CharacterName</span><span class="br0">)</span><span class="br0">)</span>;
                <span class="kw1">if</span> <span class="br0">(</span> AmbientGlow == <span class="nu0">70</span> <span class="br0">)</span>
                        AmbientGlow = <span class="kw1">Default</span>.<span class="me1">AmbientGlow</span>;
        <span class="co1">//bNetNotify = false;</span>
    <span class="br0">}</span>
 
        <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>bInKarma == <span class="kw9">false</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bKarma == <span class="kw9">false</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>Physics == PHYS_KarmaRagdoll<span class="br0">)</span> <span class="br0">)</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>; <span class="co1">// ok release karma mode go back to a pawn</span>
 
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw8">Tick</span><span class="br0">(</span><span class="kw4">float</span> DeltaTime<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="kw8">Role</span> == <span class="kw9">ROLE_Authority</span> <span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>bTickMe<span class="br0">)</span> <span class="br0">{</span>
                iTickTime--;
                <span class="kw1">if</span> <span class="br0">(</span>iTickTime &lt; <span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
                        bTickMe = <span class="kw9">false</span>;
                        UnKarmaMe<span class="br0">(</span><span class="br0">)</span>;
                <span class="br0">}</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
 
    <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>bInKarma &amp;&amp; !bTearOff<span class="br0">)</span> <span class="br0">)</span> <span class="co1">// if we're in karma, but not dead, prevent player induced motion from occuring.</span>
    <span class="br0">{</span>
        Acceleration = <span class="kw4">vect</span><span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
        Velocity = <span class="kw4">vect</span><span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
    <span class="br0">}</span>
    <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>Physics != PHYS_KarmaRagdoll<span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bKarma == <span class="kw9">true</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bInKarma == <span class="kw9">false</span><span class="br0">)</span> <span class="br0">)</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>; <span class="co1">//set the Ragdoll Mode</span>
 
    <span class="kw1">if</span> <span class="br0">(</span> <span class="kw8">Level</span>.<span class="kw8">NetMode</span> == <span class="kw9">NM_DedicatedServer</span> <span class="br0">)</span>
                <span class="kw1">return</span>;
  <span class="co1">//****** ONLY LOCAL AND CLIENT STUFF BELOW HERE</span>
 
    <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>Physics != PHYS_KarmaRagdoll<span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bClKarma == <span class="kw9">false</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bInKarma == <span class="kw9">true</span><span class="br0">)</span> <span class="br0">)</span> KarmaMe<span class="br0">(</span><span class="br0">)</span>; <span class="co1">//Seems replication isnt perfect, so lets make sure</span>
 
    <span class="kw1">if</span> <span class="br0">(</span> Controller != <span class="kw9">None</span> <span class="br0">)</span> OldController = Controller;
 
    <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>bInKarma == <span class="kw9">true</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bKarma == <span class="kw9">false</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>Physics != PHYS_KarmaRagdoll<span class="br0">)</span> <span class="br0">)</span> SetPhysics<span class="br0">(</span>PHYS_KarmaRagdoll<span class="br0">)</span>; <span class="co1">// Enforce Ragdoll on clients</span>
 
    TickFX<span class="br0">(</span>DeltaTime<span class="br0">)</span>;
 
    <span class="kw1">if</span> <span class="br0">(</span> bDeRes <span class="br0">)</span>
    <span class="br0">{</span>
        TickDeRes<span class="br0">(</span>DeltaTime<span class="br0">)</span>;
    <span class="br0">}</span>
    <span class="co1">// assume dead if bTearOff - for remote clients unfff unfff</span>
    <span class="kw1">if</span> <span class="br0">(</span> bTearOff <span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span> !bPlayedDeath <span class="br0">)</span>
            PlayDying<span class="br0">(</span>HitDamageType, TakeHitLocation<span class="br0">)</span>;
        <span class="kw1">return</span>;
    <span class="br0">}</span>
 
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> UnKarmaMe<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span><span class="kw8">ROLE</span> != <span class="kw9">Role_Authority</span><span class="br0">)</span> <span class="br0">{</span>
 
                KarmaParamsSkel<span class="br0">(</span>KParams<span class="br0">)</span>.<span class="me1">KSkeleton</span> = <span class="st0">""</span>;
                SetPhysics<span class="br0">(</span>PHYS_Falling<span class="br0">)</span>;   <span class="co1">// Reset physics</span>
                bCollideWorld = <span class="kw9">true</span>;       <span class="co1">// And world collision</span>
                                                                        <span class="co1">// (KActors use KSetBlockKarma for that)</span>
                SetCollision<span class="br0">(</span><span class="kw9">true</span>, <span class="kw9">true</span> , <span class="kw9">true</span><span class="br0">)</span>; <span class="co1">// Block actors and players again</span>
 
                LinkMesh<span class="br0">(</span> SkeletalMesh<span class="st0">'Weapons.AssaultRifle_1st'</span> <span class="br0">)</span>;
                LinkMesh<span class="br0">(</span> SafeMesh <span class="br0">)</span>;
                bClKarma = <span class="kw9">false</span>;
        <span class="br0">}</span> 
 
        <span class="kw1">if</span> <span class="br0">(</span> <span class="kw8">Role</span> == <span class="kw9">ROLE_Authority</span> <span class="br0">)</span> <span class="br0">{</span> <span class="co1">//servers set the parameters</span>
 
                bKarma = <span class="kw9">false</span>;
                bInKarma = <span class="kw9">false</span>;
        <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p>In your KarmaMe() routine, add this to your karma code:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw1">if</span> <span class="br0">(</span><span class="kw8">ROLE</span> == <span class="kw9">Role_Authority</span><span class="br0">)</span> 
        <span class="br0">{</span>
                bKarma = <span class="kw9">false</span>;
                bInKarma = <span class="kw9">true</span>;
        <span class="br0">}</span>
        <span class="kw1">if</span> <span class="br0">(</span> <span class="kw8">Level</span>.<span class="kw8">NetMode</span> != <span class="kw9">NM_DedicatedServer</span> <span class="br0">)</span>
        <span class="br0">}</span>
 
... <span class="me1">karma</span> code etc...
 
             <span class="me1">SetPhysics</span><span class="br0">(</span>PHYS_KarmaRagdoll<span class="br0">)</span>;
             bClKarma = <span class="kw9">true</span>; <span class="co1">// dont forget to let its own client know its mesh should stay in karma mode.</span>
        <span class="br0">}</span>
</pre></div>
<p>Remember, you need to set the bClKarma on the client only, the server has no idea as to what that boolean parameter is.</p>
<p>So why check for unkarma in PostNetReceive? Simple, I need to check when it changes, and not every tick. Since normally you are not in karma, and you're karma flag is false when you are playing, no point tying up CPU cycles testing a scenario that can be predicted from the server.</p>
<p>When you are ready to invoke the karma mode, use this piece of code:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw1">if</span> <span class="br0">(</span><span class="kw8">Role</span> == <span class="kw9">ROLE_Authority</span> <span class="br0">)</span> <span class="co1">// we need to set the karma ragdoll time and flag true if applicable on server only</span>
        <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span>bKarma == <span class="kw9">false</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>bInKarma == <span class="kw9">false</span><span class="br0">)</span> <span class="br0">)</span> <span class="br0">{</span> <span class="co1">// if you're already in karma mode, no need to do it agin.</span>
                        bKarma=<span class="kw9">true</span>;
                <span class="br0">}</span>
                iTickTime = iTickTime + vSize<span class="br0">(</span>momentum<span class="br0">)</span>/<span class="nu0">30</span>; <span class="co1">// or whatever you want to use.</span>
                bTickMe = <span class="kw9">true</span>;
        <span class="br0">}</span>
</pre></div>
<p>I use it in my TakeDamage function.</p>
<p>One last thing, in you class add these to your defaultproperties:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="kw1">defaultproperties</span>
<span class="br0">{</span>
        bKarma = <span class="kw9">false</span>
        bInKarma= <span class="kw9">false</span>
        bAlwaysRelevant=<span class="kw9">True</span> <span class="co1">// should already be set if its a pawn</span>
        bGameRelevant=<span class="kw9">True</span> <span class="co1">// i believe same here as above</span>
        bTickMe = <span class="kw9">false</span>
        iTickTime = <span class="nu0">0</span>
        bNetNotify=<span class="kw9">true</span> <span class="co1">// important </span>
        bClKarma = <span class="kw9">false</span>
<span class="br0">}</span>
</pre></div>
<p>Hopefully this will shed some light on the karna networking topic and get more mods looking and feeling realistic. I will add my code soon that will allow for you to successfully get your pawn back up correctly using bone lifters, and timing (notice I set the timer from the momentum parm in the takedamage function). I'm sure the code could be optimized and done in many ways, but it works, and its something to start from.</p>
<p>Good luck, and if you have any questions post em, or look for me on IRC... im usually around in #unrealwiki, #unrealed, or #unrealscript.</p>
<p><b>Foxpaw:</b> I would not recommend using bone lifters for the "getting back up" portion.. bone lifters require collision to be disabled, effectively making the player invulnerable while recovering. It would also be kind of wierd looking. I think that tweening from the dead body position back to crouching animation would be better and is probrably quite possible.</p>
<p><b>Foxpaw:</b> I got tweening back to animation to "work." So far it doesn't look all that natural though. I have an idea how to make it more natural but I'd like to do so without any hacks.</p>
<p><b>Foxpaw:</b> Improved the tweening.. making it faster makes the wierd nuances unnoticeable and bringing them back to the crouched position instead of standing helped as well. Now I only have one problem: the relinking of the mesh starts the person off in a standing position. This causes the person to tween from standing to crouching when they get up which looks a bit wierd. I know how I could probrably fix that but it's a hack, so I don't want to do it that way. Any ideas of how I could do this cleanly?</p>
<p><b>OBWANDO:</b> Drop some code in here, lets take a look. I was playing with LinkSkelAnim( (anim), (mesh) ) instead of LinkMesh. Its a native as well, but from what I see in the actor.uc, it will start the mesh up in that animation.</p>
<p><b>Foxpaw:</b> Unfortunately, since my class heirarchy is completely different, the function calls, etcetera will be different. I'll put the contents of the "skeletoncontroller" class here anyway, you can probrably see the idea. An explanation would probrably serve you better: When we return from ragdolling, before relinking the mesh we read the orientation of all of the main bones, using GetBoneCoords. The X axis of that coordinate system that it returns is a vector pointing along the length of the bone, thus giving us its rotation. I store this information, relink the meshes, then use SetBoneDirection to recreate the ragdoll's position after the relinking. The SetBoneDirection has an alpha parameter that allows us to define how much of that direction should be imposed and how much should be left to SetBoneRotation/the animations. By tweening the alpha from 1 to 0 always with the same directions, the body will go from its ragdolled position to the position dictated by its animation over the course of the time that it takes to tween the alpha. This can create wierd effects if you do it slowly, though, because of the bone heirarchy and all. If done quickly enough, however, it appears fairly smooth. The only problem with this setup is that it uses some fair network bandwidth, because for some reason setbonedirection is not simulated, even though SetBoneRotation is.</p>
<p>There are some functions that are not related to the ragdolling in here, and some interplay with a class "UniversalThing" and "SkeletalMeshController," but you should be able to get the idea from this:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="co1">// The skeleton of a skeletal mesh.</span>
<span class="kw5">class</span> SkeletonController <span class="kw5">extends</span> UniversalThing <span class="kw6">notplaceable</span>;
 
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
 
<span class="kw4">struct</span> BoneData                                 <span class="co1">// A stored bone structure, used for ragdoll recovery.</span>
<span class="br0">{</span>
  <span class="kw5">var</span> <span class="kw4">name</span>      BoneName;                       <span class="co1">// The name of this bone.</span>
  <span class="kw5">var</span> <span class="kw4">coords</span>    BoneCoords;                     <span class="co1">// The 'coordinates' of this bone.</span>
  <span class="kw5">var</span> <span class="kw4">rotator</span>   Rotation;                       <span class="co1">// The current added rotation of this bone.</span>
<span class="br0">}</span>;
 
<span class="kw4">struct</span> TweenBoneDirection
<span class="br0">{</span>
  <span class="kw5">var</span> <span class="kw4">name</span>      BoneName;                       <span class="co1">// The name of the bone.</span>
  <span class="kw5">var</span> <span class="kw4">rotator</span>   Direction;                      <span class="co1">// The direction of the bone.</span>
  <span class="kw5">var</span> <span class="kw4">float</span>     TweenTime;                      <span class="co1">// Time remaining to tween.</span>
  <span class="kw5">var</span> <span class="kw4">float</span>     StartTweenTime;                 <span class="co1">// How long to tween in total.</span>
<span class="br0">}</span>;
 
<span class="kw5">var</span> Mesh                SafeMesh1, SafeMesh2;   <span class="co1">// TODO: This is duplicated in the meshcontroller.</span>
 
<span class="kw5">var</span> array&lt;BoneData&gt;     Bones;
<span class="kw5">var</span> array&lt;TweenBoneDirection&gt; BoneTweenData;    <span class="co1">// Data for tweening of bone directions.</span>
 
<span class="kw5">var</span> array&lt;name&gt;         BoneNames;              <span class="co1">// Important bones that will be retained through ragdoll recovery.</span>
<span class="kw5">var</span> array&lt;name&gt;         AimBones;               <span class="co1">// Bones that take part in aiming.</span>
 
<span class="kw5">var</span> <span class="kw4">name</span>                HeldBone;               <span class="co1">// Bone that we use for holding things.</span>
<span class="kw5">var</span> <span class="kw4">name</span>                ViewBone;               <span class="co1">// Bone that the camera should view from.</span>
 
<span class="kw5">var</span> <a href="/Actor"><span class="kw10">actor</span></a>               Flesh;                  <span class="co1">// Our "flesh."</span>
 
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> postbeginplay<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw6">Super</span>.<span class="me1">postbeginplay</span><span class="br0">(</span><span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> Initialize<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">int</span> i;
 
  Flesh.<span class="me1">AnimBlendParams</span><span class="br0">(</span><span class="nu0">1</span>, <span class="nu0">1.0</span>, <span class="nu0">0.0</span>, <span class="nu0">0.2</span>, AimBones<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span>;
 
  <span class="kw1">for</span> <span class="br0">(</span>i=<span class="nu0">0</span>;i&lt;BoneNames.<span class="kw6">Length</span>;i++<span class="br0">)</span>
    SetBoneRot<span class="br0">(</span> BoneNames<span class="br0">[</span>i<span class="br0">]</span>, Rot<span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span> <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> BoneData StoreBone<span class="br0">(</span> <span class="kw4">name</span> BoneName <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> BoneData NewBone;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span> NewBone;
 
  NewBone.<span class="me1">BoneName</span> = BoneName;
  NewBone.<span class="me1">BoneCoords</span> = Flesh.<span class="me1">GetBoneCoords</span><span class="br0">(</span> BoneName <span class="br0">)</span>;
 
  <span class="kw1">return</span> NewBone;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> array&lt;BoneData&gt; StoreBoneData<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">int</span> i;
  <span class="kw5">local</span> array&lt;BoneData&gt; BoneData;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span> BoneData;
 
  <span class="kw1">for</span> <span class="br0">(</span>i=<span class="nu0">0</span>;i&lt;Default.<span class="me1">BoneNames</span>.<span class="kw6">Length</span>;i++<span class="br0">)</span>
    BoneData<span class="br0">[</span>BoneData.<span class="kw6">Length</span><span class="br0">]</span> = StoreBone<span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">BoneNames</span><span class="br0">[</span>i<span class="br0">]</span> <span class="br0">)</span>;
 
  <span class="kw1">return</span> BoneData;
<span class="br0">}</span>
 
 
<span class="co1">// Set me back up for animation after I've ragdolled.</span>
<span class="kw6">simulated</span> <span class="kw5">function</span> SolidifyRagdoll<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> array&lt;BoneData&gt; BoneData;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
 
  BoneData = StoreBoneData<span class="br0">(</span><span class="br0">)</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span> <span class="br0">(</span> Flesh.<span class="me1">Mesh</span> == <span class="kw1">Default</span>.<span class="me1">SafeMesh1</span> || <span class="kw1">Default</span>.<span class="me1">SafeMesh1</span> == <span class="kw9">None</span> <span class="br0">)</span> &amp;&amp; <span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">SafeMesh2</span> != <span class="kw9">None</span> <span class="br0">)</span> <span class="br0">)</span>
    Flesh.<span class="me1">LinkMesh</span><span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">SafeMesh2</span> <span class="br0">)</span>;
  <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">SafeMesh1</span> != <span class="kw9">None</span> <span class="br0">)</span>
    Flesh.<span class="me1">LinkMesh</span><span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">SafeMesh1</span> <span class="br0">)</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span> UniversalThing<span class="br0">(</span> Flesh <span class="br0">)</span> != <span class="kw9">None</span> <span class="br0">)</span>
    UniversalThing<span class="br0">(</span>Flesh<span class="br0">)</span>.<span class="me1">InitializeMesh</span><span class="br0">(</span><span class="br0">)</span>;
 
  RecoverBoneData<span class="br0">(</span> BoneData <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> RecoverBoneData<span class="br0">(</span> array&lt;BoneData&gt; BoneData <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">int</span> i;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
 
  <span class="kw1">for</span> <span class="br0">(</span>i=<span class="nu0">0</span>;i&lt;BoneData.<span class="kw6">Length</span>;i++<span class="br0">)</span>
    RecoverBone<span class="br0">(</span> BoneData<span class="br0">[</span>i<span class="br0">]</span> <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> RecoverBone<span class="br0">(</span> BoneData BoneData <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
 
  Flesh.<span class="me1">SetBoneLocation</span><span class="br0">(</span> BoneData.<span class="me1">BoneName</span>, BoneData.<span class="me1">BoneCoords</span>.<span class="me1">Origin</span> <span class="br0">)</span>;
  SetBoneDir<span class="br0">(</span> BoneData.<span class="me1">BoneName</span>, <span class="kw4">Rotator</span><span class="br0">(</span> BoneData.<span class="me1">BoneCoords</span>.<span class="me1">XAxis</span> <span class="br0">)</span>,<span class="nu0">0.25</span> <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> TweakBoneRotation<span class="br0">(</span> <span class="kw4">name</span> BoneName, <span class="kw6">out</span> <span class="kw4">rotator</span> Rot <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> BoneName == HeldBone <span class="br0">)</span>
    Rot += Rot<span class="br0">(</span><span class="nu0">16384</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
 
  <span class="co1">///// Note: This function is best described as a "hack." It allows a meshcontroller to</span>
  <span class="co1">///// manually override bone directions by assigning a fixed direction to them. It will</span>
  <span class="co1">///// not work properly on bones that take part in aiming, etc. It merely exists as a</span>
  <span class="co1">///// method to retrofit existing models with bones in wierd orientations.</span>
<span class="br0">}</span>
 
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> SetAim<span class="br0">(</span> <span class="kw4">rotator</span> Aim <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">int</span> i;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
 
  <span class="co1">// TODO: Hackriffic. Make the transormation matrix confusitroniness. Maybe make a "skeleton" class,</span>
  <span class="co1">// which would be owned by the Thing, that stores our current animation positions. Technically that</span>
  <span class="co1">// should go here so maybe the meshcontroller could be instantiated.</span>
  Flesh.<span class="me1">SetRotation</span><span class="br0">(</span> Aim <span class="br0">)</span>;
 
  Aim -= Flesh.<span class="me1">Rotation</span>;
 
  <span class="kw1">for</span> <span class="br0">(</span>i=<span class="nu0">0</span>;i&lt;Default.<span class="me1">AimBones</span>.<span class="kw6">Length</span>;i++<span class="br0">)</span>
  <span class="br0">{</span>
    Aim.<span class="me1">Roll</span> =  Aim.<span class="me1">Yaw</span>;
    Aim.<span class="me1">Yaw</span>  = -Aim.<span class="me1">Pitch</span>;
    Aim.<span class="me1">Pitch</span> = <span class="nu0">0</span>;
    SetBoneRot<span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">AimBones</span><span class="br0">[</span>i<span class="br0">]</span>, Aim / <span class="kw1">Default</span>.<span class="me1">AimBones</span>.<span class="kw6">Length</span> <span class="br0">)</span>;
  <span class="br0">}</span>
 
  <span class="kw1">return</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw4">vector</span> FindBoneLocation<span class="br0">(</span> <span class="kw4">name</span> Bone, <span class="kw6">optional</span> <span class="kw6">out</span> <span class="kw4">vector</span> Rot <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">Coords</span> <span class="kw4">Coords</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> || Bone == <span class="st0">''</span> <span class="br0">)</span> <span class="kw1">return</span> <span class="kw4">Vect</span><span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
 
  <span class="kw4">Coords</span> = Flesh.<span class="me1">GetBoneCoords</span><span class="br0">(</span> Bone <span class="br0">)</span>;
  Rot = <span class="kw4">Coords</span>.<span class="me1">XAxis</span>;
  <span class="kw1">return</span> <span class="kw4">Coords</span>.<span class="me1">Origin</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw4">rotator</span> FindBoneRotation<span class="br0">(</span> <span class="kw4">name</span> Bone <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> || Bone == <span class="st0">''</span> <span class="br0">)</span> <span class="kw1">return</span> Rot<span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
 
  <span class="kw1">return</span> Flesh.<span class="me1">GetBoneRotation</span><span class="br0">(</span> Bone <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="co1">// TODO: This function name is misleading.</span>
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw4">vector</span> FindHeldLocation<span class="br0">(</span> <span class="kw6">optional</span> <span class="kw6">out</span> <span class="kw4">vector</span> Rot <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> || <span class="kw1">Default</span>.<span class="me1">HeldBone</span> == <span class="st0">''</span> <span class="br0">)</span> <span class="kw1">return</span> <span class="kw4">Vect</span><span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
 
  <span class="kw1">return</span> FindBoneLocation<span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">HeldBone</span>, Rot <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="co1">// TODO: This function name is misleading.</span>
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw4">vector</span> FindHeldRotation<span class="br0">(</span> <span class="kw6">optional</span> <span class="kw6">out</span> <span class="kw4">vector</span> Loc <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> || <span class="kw1">Default</span>.<span class="me1">HeldBone</span> == <span class="st0">''</span> <span class="br0">)</span> <span class="kw1">return</span> <span class="kw4">Vect</span><span class="br0">(</span><span class="nu0">0</span>,<span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">)</span>;
 
  Loc = FindBoneLocation<span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">HeldBone</span> <span class="br0">)</span>;
  <span class="kw1">return</span> <span class="kw4">Vector</span><span class="br0">(</span> FindBoneRotation<span class="br0">(</span> <span class="kw1">Default</span>.<span class="me1">HeldBone</span> <span class="br0">)</span> <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> SetBoneRot<span class="br0">(</span> <span class="kw4">name</span> BoneName, <span class="kw4">rotator</span> Rot <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
  TweakBoneRotation<span class="br0">(</span> BoneName, Rot <span class="br0">)</span>;
  Flesh.<span class="me1">SetBoneRotation</span><span class="br0">(</span> BoneName, Rot <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw5">function</span> SetBoneDir<span class="br0">(</span> <span class="kw4">name</span> BoneName, <span class="kw4">rotator</span> Dir, <span class="kw6">optional</span> <span class="kw4">float</span> TweenTime <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> TweenBoneDirection NewTween;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span> TweenTime != <span class="nu0">0</span> <span class="br0">)</span>
  <span class="br0">{</span>
    NewTween.<span class="me1">BoneName</span> = BoneName;
    NewTween.<span class="me1">Direction</span> = Dir;
    NewTween.<span class="me1">TweenTime</span> = TweenTime;
    NewTween.<span class="me1">StartTweenTime</span> = TweenTime;
    BoneTweenData<span class="br0">[</span>BoneTweenData.<span class="kw6">Length</span><span class="br0">]</span> = NewTween;
  <span class="br0">}</span>
 
  Flesh.<span class="me1">SetBoneDirection</span><span class="br0">(</span> BoneName, Dir,,<span class="nu0">1</span> <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw5">function</span> <span class="kw4">bool</span> TweenBone<span class="br0">(</span> <span class="kw6">out</span> TweenBoneDirection BoneData, <span class="kw4">float</span> Delta <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">bool</span> Result;
  Result = <span class="kw9">false</span>;
 
  <span class="kw1">if</span> <span class="br0">(</span> Flesh == <span class="kw9">None</span> <span class="br0">)</span> <span class="kw1">return</span> Result;
 
  BoneData.<span class="me1">TweenTime</span> -= Delta;
  <span class="kw1">if</span> <span class="br0">(</span> BoneData.<span class="me1">TweenTime</span> &lt; <span class="nu0">0</span> <span class="br0">)</span>
  <span class="br0">{</span>
    BoneData.<span class="me1">TweenTime</span> = <span class="nu0">0</span>;
    Result = <span class="kw9">true</span>;
  <span class="br0">}</span>
 
  Flesh.<span class="me1">SetBoneDirection</span><span class="br0">(</span> BoneData.<span class="me1">BoneName</span>, BoneData.<span class="me1">Direction</span>,,BoneData.<span class="me1">TweenTime</span>/BoneData.<span class="me1">StartTweenTime</span> <span class="br0">)</span>;
 
  <span class="kw1">return</span> Result;
<span class="br0">}</span>
 
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
 
<span class="kw6">simulated</span> <span class="kw5">function</span> <span class="kw8">Tick</span><span class="br0">(</span> <span class="kw4">float</span> Delta <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw5">local</span> <span class="kw4">int</span> i;
 
  <span class="kw1">for</span> <span class="br0">(</span>i=<span class="nu0">0</span>;i&lt;BoneTweenData.<span class="kw6">Length</span>;i++<span class="br0">)</span>
    <span class="kw1">if</span> <span class="br0">(</span> TweenBone<span class="br0">(</span> BoneTweenData<span class="br0">[</span>i<span class="br0">]</span>, Delta <span class="br0">)</span> <span class="br0">)</span>
      BoneTweenData.<span class="kw6">Remove</span><span class="br0">(</span>i,<span class="nu0">1</span><span class="br0">)</span>;
 
  <span class="kw6">Super</span>.<span class="kw8">Tick</span><span class="br0">(</span> Delta <span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
<span class="co1">// **************************************************************************************** //</span>
 
<span class="kw1">defaultproperties</span>
<span class="br0">{</span>
  Bonenames<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>=Spine
  Bonenames<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span>=Head
  Bonenames<span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span>=LShoulder
  Bonenames<span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span>=RShoulder
  Bonenames<span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span>=LThigh
  Bonenames<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span>=RThigh
  Bonenames<span class="br0">(</span><span class="nu0">6</span><span class="br0">)</span>=LFARM
  Bonenames<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span>=RFARM
  Bonenames<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span>=RightHand
  Bonenames<span class="br0">(</span><span class="nu0">9</span><span class="br0">)</span>=LFoot
  Bonenames<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span>=RFoot
  Bonenames<span class="br0">(</span><span class="nu0">11</span><span class="br0">)</span>=Bone_Weapon
 
  AimBones<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>=Spine
 
  HeldBone=Bone_Weapon
  ViewBone=Head
 
  SafeMesh1=Mesh<span class="st0">'Jugg.JuggMaleA'</span>
  SafeMesh2=Mesh<span class="st0">'Jugg.JuggFemaleA'</span>
<span class="br0">}</span>
</pre></div>
<p><b>AlphaOne:</b> Could I ask anyone to please taker their time to post a <b>complete</b> solution(s) here because I'm having a hard time putting your code together. It would be REALLY nice if it was downloadable...(I like being spoon fed)</p>
<p><b>Foxpaw:</b> Unfortunately, because all of the people working on this have different applications it's kind of hard to package one solution.. however, I suspect that a mutator could be made of this (I think theres a modifydamage function or something that could cause the karmatizing and an array of pointers to pawns and their respective karma-ing specific values could possibly be stored there. Unfortunately, since my application is highly different, I can't really be the one to do this. Most of the snippets I've provided here are fairly general, but the last one is highly specific and wouldn't work without extensive modification.</p>
<p><b>Plane Guy:</b> RAGDOLL POSTULATION OUT OF NOWHERE. My mod involves grabbing a player pawn and dragging him around. Thing is, with the ragdoll I have to attach to a bone and karma yank the doll around BUT the server has no ragdoll (else it crashes). Would it be plausible to karma impulse the "standing" player pawn on the server and get karma-based dragging client-side? Does the flippity-floppity nature of ragdolls require I act on it directly with Karma, or will the client recognize the server has moved the doll and flail its limbs accordingly?</p>
<p><b>Foxpaw:</b> Hmm, I'm pretty sure that it's possible to have an actor using PHYS_KarmaRagdoll on the server.. though I don't know how well xPawns handle that. Anyways, Karma ragdolls don't replicate very well, so it would probrably be best to do the bone attach to whatever they're getting dragged behind and have the dragging completely client side. (And have whatever is dragging them get replicated)</p>
<p><b>Plane Guy:</b> Hmmmm. Well I had it working on client-side only, but when the dragging stops, the pawn reappears where it was first ragdolled. Would I have to replicate that movement BACK to the server (server is NOT the man, oh noes)? Wouldn't I have to, once replicated to the server, replicate it back to the other clients? Gee, this is getting complicated.</p>
<p><b>Foxpaw:</b> I recall someone else having a similar issue. This seems to be a behaviour of the xPawn class, though I can't say that with 100% certainty. xPawns store movements and then go off of their saved movement - this reduces apparent lag in network games. However, it also means that if you move a Pawn by a means other than the Pawn was intended to move, the stored movements don't get updated. I'm not sure if there's an easy way around that or not, since I haven't really looked at the network stuff for Pawn.</p>
<p><b>Dirk Fist:</b> I have'nt done much with 2k3, But could'nt the <i>Actor&gt;NavigationPoint&gt;SmallNavigationPoint&gt;Teleporter</i> accept() function, be modified for setting an actors location?</p>
<p><b>Plane Guy:</b> I don't know if it matters, but I'm in 2K4 now. Perhaps a "ragdoll location" variable, and have the server actor.move() to it while ragdolled. It'd be choppy though, though since the server is going to update the client with its old location.</p>
<p>The other idea I had was to karma impluse the same on all clients - replicate the impulse vector - and actor.move() only on the server. Everyone'd get a slightly different karma show, but I don't think they'd notice.</p>
<p><b>OlympusMons:</b> Ok guys just an idea. I was thinking after reading this, I know it need a <a href="../../../../articles/l/e/g/Category%7ELegacy_Refactor_Me_699c.html" title="Category:Legacy Refactor Me">Category:Legacy Refactor Me</a> Please! Anyways I was thinking maybe you could subclass svehicle or ONSvehicle or one of those and since those are pawns, which use skeletal anims and karma, maybe you could make the player use a pawn and hope in then when you get KO'd you hope out of the vehicle, play KO stuff, then hop back in. Just an idea anyways Im not really skilled at uscript, yet hehe, so i'm not going to attempt this, yet hehe. Well feel free to give me what for if I dunno what Im talking about.</p>

<!-- 
NewPP limit report
Preprocessor node count: 50/1000000
Post-expand include size: 54/2097152 bytes
Template argument size: 0/2097152 bytes
#ifexist count: 0/100
-->
<div class="printfooter">
</div>
	    <div id="catlinks"><p class='catlinks'><a href="../../../../articles/c/a/t/Special%7ECategories_101d.html" title="Special:Categories">Category</a>: <span dir='ltr'><a href="../../../../articles/l/e/g/Category%7ELegacy_Refactor_Me_699c.html" title="Category:Legacy Refactor Me">Legacy Refactor Me</a></span></p></div>	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-legacy"
	       class="selected"	       ><a href="../../../../articles/k/a/r/Legacy%7EKarma_Ragdoll_Injury_System_e14c.html">Legacy</a></li><li id="ca-talk"
	       class="new"	       ><a href="../../../../articles/k/a/r/Legacy_talk%7EKarma_Ragdoll_Injury_System_a10d.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://wiki.beyondunreal.com/Legacy:Karma_Ragdoll_Injury_System">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../../misc/uewiki.png);"
	    href="../../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-mainpage"><a href="../../../../index.html">Main Page</a></li>
	     	      <li id="n-portal"><a href="../../../../articles/c/o/m/Unreal_Wiki%7ECommunity_Portal_3311.html">Community portal</a></li>
	     	      <li id="n-help"><a href="../../../../articles/c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="../../../../../COPYING.html"><img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" alt='Attribution-Noncommercial-Share Alike 3.0' /></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 09:22, 14 September 2006 by Unreal Wiki user <a href="../../../../articles/w/o/r/User%7EWormbo_7d13.html" title="User:Wormbo">Wormbo</a>. Based on work by Anonymous user(s) of Unreal Wiki.</li>	  <li id="f-copyright">Licensed as <a href="../../../../articles/c/o/p/Unreal_Wiki%7ECopyrights_e561.html" title="Unreal Wiki:Copyrights">Attribution-Noncommercial-Share Alike 3.0</a>.</li>	  <li id="f-about"><a href="../../../../articles/a/b/o/Unreal_Wiki%7EAbout_9ce6.html" title="Unreal Wiki:About">About Unreal Wiki</a></li>	  <li id="f-disclaimer"><a href="../../../../articles/g/e/n/Unreal_Wiki%7EGeneral_disclaimer_a0a2.html" title="Unreal Wiki:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
