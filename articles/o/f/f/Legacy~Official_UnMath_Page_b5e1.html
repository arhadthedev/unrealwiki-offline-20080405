<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<!-- headlinks removed -->
	<link rel="shortcut icon" href="../../../../misc/uewiki-favicon.png"/>
    <title>Legacy:Official UnMath Page - Unreal Wiki</title>
    <style type="text/css">/*<![CDATA[*/ @import "../../../../skins/offline/main.css"; /*]]>*/</style>
    <link rel="stylesheet" type="text/css" media="print" href="../../../../skins/common/commonPrint.css" />
    <!--[if lt IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE50Fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "../../../../skins/monobook/IE55Fixes.css";</style><![endif]-->
    <!--[if IE 6]><style type="text/css">@import "../../../../skins/monobook/IE60Fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="../../../../skins/common/IEFixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
    <script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/md5.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/utf8.js"></script>
    <script type="text/javascript" src="../../../../skins/offline/lookup.js"></script>
    <script type="text/javascript" src="../../../../articles/-/_/_/-.html"></script>        <style type="text/css">/*<![CDATA[*/
@import "../../../../articles/c/o/m/MediaWiki%7ECommon.css_d42e.html";
@import "../../../../articles/m/o/n/MediaWiki%7EMonobook.css_fb19.html";
@import "../../../../articles/-/_/_/-.html";
/*]]>*/</style>          </head>
  <body
    class="ns-100">
    <div id="globalWrapper">
      <div id="column-content">
	<div id="content">
	  <a name="top" id="contentTop"></a>
	        <h1 class="firstHeading">Legacy:Official UnMath Page</h1>
	  <div id="bodyContent">
	    <h3 id="siteSub">From Unreal Wiki, The Unreal Engine Documentation Site</h3>
	    <div id="contentSub"></div>
	    	    	    <!-- start content -->
	    <p><a name="Introduction" id="Introduction"></a></p>
<h2><span class="mw-headline">Introduction</span></h2>
<p>The UnMath.h Header File (from, <a href="http://unreal.epicgames.com/files/ut432pubsrc.zip" class="external text" title="http://unreal.epicgames.com/files/ut432pubsrc.zip" rel="nofollow">Unreal Tournament 432 C++ Publicly Released Headers</a>) might more properly belong in the Unreal Engine Core section, since it is integral to every critical process that the Engine performs.<br /></p>
<p>The Official UnMath Page is derived from that Header File Released from Epic Games and coded in C++. The following is just a section from the file, that describes FVectors. It appears in the original Tim Sweeney code; an uncompiled text file.<br /></p>
<p>The complete UnMath.h file contains all the mathematical routines used by the Unreal Engine for collision detection, the Artificial Intelligence of Bots, and the physics (yes, even the Quaternion Rotations), and, ultimately, the rendering of the scene. It's WAY l33t,...but, unfortunately, WAY humungeous.<br /></p>
<p>We should have an analysis page to acompany it.<br /></p>
<p>It will take you at least 5 years to read it all,...and by that time the Engine hierarchy will have evolved into something incomprehensible and extremely highly advanced.</p>
<p><i>Preface:</i> The acronym API stands for Application Programming Interface. Just to give you an idea of the insane complexity of the UnMath routines, I have included a snippet of code for an important function <u><b>FuzzVectors</b></u>:</p>
<div dir="ltr" style="text-align: left;" class="highlighted-source">
<pre class="source-uscript">
<span class="coMULTI">/*-----------------------------------------------------------------------------
        FVector.
 -----------------------------------------------------------------------------*/</span>
 <span class="co1">// Information associated with a floating point vector, describing its</span>
 <span class="co1">// status as a point in a rendering context.</span>
 <span class="kw4">enum</span> EVectorFlags
 <span class="br0">{</span>
        FVF_OutXMin             = 0x04, <span class="co1">// Outcode rejection, off left hand side of screen.</span>
        FVF_OutXMax             = 0x08, <span class="co1">// Outcode rejection, off right hand side of screen.</span>
        FVF_OutYMin             = 0x10, <span class="co1">// Outcode rejection, off top of screen.</span>
        FVF_OutYMax             = 0x20, <span class="co1">// Outcode rejection, off bottom of screen.</span>
        FVF_OutNear     = 0x40, <span class="co1">// Near clipping plane.</span>
        FVF_OutFar      = 0x80, <span class="co1">// Far clipping plane.</span>
        FVF_OutReject   = <span class="br0">(</span>FVF_OutXMin | FVF_OutXMax | FVF_OutYMin | FVF_OutYMax<span class="br0">)</span>, <span class="co1">//  Outcode rejectable.</span>
        FVF_OutSkip             = <span class="br0">(</span>FVF_OutXMin | FVF_OutXMax | FVF_OutYMin | FVF_OutYMax<span class="br0">)</span>, <span class="co1">// Outcode clippable.</span>
 <span class="br0">}</span>;
 
 <span class="co1">//</span>
 <span class="co1">// Floating point vector.</span>
 <span class="co1">// Playstation2 vectors are 16 bytes.</span>
 <span class="co1">//</span>
 <span class="kw2">#if</span> __PSX2_EE__
 <span class="kw2">#define</span> FVECTOR_ALIGNMENT <span class="nu0">16</span>
 <span class="kw5">class</span> CORE_API FVector 
 <span class="br0">{</span>
 public:
        <span class="co1">// Variables.</span>
        <span class="kw4">FLOAT</span> X, Y, Z, W;
 
        <span class="co1">// Constructors.</span>
        FVector<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span><span class="br0">}</span>
 
        FVector<span class="br0">(</span> <span class="kw4">FLOAT</span> InX, <span class="kw4">FLOAT</span> InY, <span class="kw4">FLOAT</span> InZ <span class="br0">)</span>
        :       X<span class="br0">(</span>InX<span class="br0">)</span>, Y<span class="br0">(</span>InY<span class="br0">)</span>, Z<span class="br0">(</span>InZ<span class="br0">)</span>, W<span class="br0">(</span><span class="nu0">1</span>.<span class="me1">f</span><span class="br0">)</span>
        <span class="br0">{</span><span class="br0">}</span>
 
        <span class="co1">// Binary math operators.</span>
        inline FVector <span class="kw6">operator</span>^<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%1)
                        lqc2            vf3, 0x00(%2)
                        vopmula.xyz     ACCxyz, vf2xyz, vf3xyz
                        vopmsub.xyz     vf1xyz, vf3xyz, vf2xyz
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
        inline <span class="kw4">FLOAT</span> operator|<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%1)
                        lqc2            vf3, 0x00(%2)
                        vmul.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r.<span class="me1">X</span> + r.<span class="me1">Y</span> + r.<span class="me1">Z</span>;
        <span class="br0">}</span>
        friend FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span>, <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> V.<span class="me1">X</span> * <span class="kw4">Scale</span>, V.<span class="me1">Y</span> * <span class="kw4">Scale</span>, V.<span class="me1">Z</span> * <span class="kw4">Scale</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>+<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%1)
                        lqc2            vf3, 0x00(%2)
                        vadd.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
        inline FVector operator-<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%1)
                        lqc2            vf3, 0x00(%2)
                        vsub.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        ctc2            %2,  $21
                        lqc2            vf2, 0x00(%1)
                        vmuli.xyz       vf1, vf2, I
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span><span class="kw4">Scale</span><span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>/<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RScale = <span class="nu0">1</span>.<span class="me1">f</span>/<span class="kw4">Scale</span>;
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        ctc2            %2,  $21
                        lqc2            vf2, 0x00(%1)
                        vmuli.xyz       vf1, vf2, I
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>RScale<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                FVector r;
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%1)
                        lqc2            vf3, 0x00(%2)
                        vmul.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>&amp;r<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> r;
        <span class="br0">}</span>
 
        <span class="co1">// Binary comparison operators.</span>
        UBOOL <span class="kw6">operator</span>==<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X==V.<span class="me1">X</span> &amp;&amp; Y==V.<span class="me1">Y</span> &amp;&amp; Z==V.<span class="me1">Z</span>;
        <span class="br0">}</span>
        UBOOL <span class="kw6">operator</span>!=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X!=V.<span class="me1">X</span> || Y!=V.<span class="me1">Y</span> || Z!=V.<span class="me1">Z</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Unary operators.</span>
        FVector operator-<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> -X, -Y, -Z <span class="br0">)</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Assignment operators.</span>
        inline FVector <span class="kw6">operator</span>+=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%0)
                        lqc2            vf3, 0x00(%1)
                        vadd.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                : 
                : <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        inline FVector operator-=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%0)
                        lqc2            vf3, 0x00(%1)
                        vsub.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                : 
                : <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>*=<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span>
        <span class="br0">{</span>
                asm volatile <span class="br0">(</span><span class="st0">"
                        ctc2            %1,  $21
                        lqc2            vf2, 0x00(%0)
                        vmuli.xyz       vf1, vf2, I
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span><span class="kw4">Scale</span><span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>/=<span class="br0">(</span> <span class="kw4">FLOAT</span> V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RScale = <span class="nu0">1</span>.<span class="me1">f</span>/V;
                asm volatile <span class="br0">(</span><span class="st0">"
                        ctc2            %1,  $21
                        lqc2            vf2, 0x00(%0)
                        vmuli.xyz       vf1, vf2, I
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>RScale<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        inline FVector <span class="kw6">operator</span>*=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                asm volatile <span class="br0">(</span><span class="st0">"
                        lqc2            vf2, 0x00(%0)
                        lqc2            vf3, 0x00(%1)
                        vmul.xyz        vf1, vf2, vf3
                        sqc2            vf1, 0x00(%0)
                "</span>
                :
                : <span class="st0">"r"</span> <span class="br0">(</span>this<span class="br0">)</span>, <span class="st0">"r"</span> <span class="br0">(</span>&amp;V<span class="br0">)</span>
                : <span class="st0">"memory"</span>
                <span class="br0">)</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>/=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                X /= V.<span class="me1">X</span>; Y /= V.<span class="me1">Y</span>; Z /= V.<span class="me1">Z</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
 
        <span class="co1">// Simple functions.</span>
        <span class="kw4">FLOAT</span> Size<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> appSqrt<span class="br0">(</span> X*X + Y*Y + Z*Z <span class="br0">)</span>;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> SizeSquared<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X*X + Y*Y + Z*Z;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> Size2D<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span> 
        <span class="br0">{</span>
                <span class="kw1">return</span> appSqrt<span class="br0">(</span> X*X + Y*Y <span class="br0">)</span>;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> SizeSquared2D<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span> 
        <span class="br0">{</span>
                <span class="kw1">return</span> X*X + Y*Y;
        <span class="br0">}</span>
        <span class="kw4">int</span> IsNearlyZero<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span>
                                <span class="kw7">Abs</span><span class="br0">(</span>X<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER
                        &amp;&amp;      <span class="kw7">Abs</span><span class="br0">(</span>Y<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER
                        &amp;&amp;      <span class="kw7">Abs</span><span class="br0">(</span>Z<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER;
        <span class="br0">}</span>
        UBOOL IsZero<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X==<span class="nu0">0</span>.<span class="me1">f</span> &amp;&amp; Y==<span class="nu0">0</span>.<span class="me1">f</span> &amp;&amp; Z==<span class="nu0">0</span>.<span class="me1">f</span>;
        <span class="br0">}</span>
        UBOOL Normalize<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> SquareSum = X*X+Y*Y+Z*Z;
                <span class="kw1">if</span><span class="br0">(</span> SquareSum &gt;= SMALL_NUMBER <span class="br0">)</span>
                <span class="br0">{</span>
                        <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> = <span class="nu0">1</span>.<span class="me1">f</span>/appSqrt<span class="br0">(</span>SquareSum<span class="br0">)</span>;
                        X *= <span class="kw4">Scale</span>; Y *= <span class="kw4">Scale</span>; Z *= <span class="kw4">Scale</span>;
                        <span class="kw1">return</span> <span class="nu0">1</span>;
                <span class="br0">}</span>
                <span class="kw1">else</span> <span class="kw1">return</span> <span class="nu0">0</span>;
        <span class="br0">}</span>
        FVector Projection<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RZ = <span class="nu0">1</span>.<span class="me1">f</span>/Z;
                <span class="kw1">return</span> FVector<span class="br0">(</span> X*RZ, Y*RZ, <span class="nu0">1</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector UnsafeNormal<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> = <span class="nu0">1</span>.<span class="me1">f</span>/appSqrt<span class="br0">(</span>X*X+Y*Y+Z*Z<span class="br0">)</span>;
                <span class="kw1">return</span> FVector<span class="br0">(</span> X*<span class="kw4">Scale</span>, Y*<span class="kw4">Scale</span>, Z*<span class="kw4">Scale</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector GridSnap<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Grid <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> FSnap<span class="br0">(</span>X, Grid.<span class="me1">X</span><span class="br0">)</span>,FSnap<span class="br0">(</span>Y, Grid.<span class="me1">Y</span><span class="br0">)</span>,FSnap<span class="br0">(</span>Z, Grid.<span class="me1">Z</span><span class="br0">)</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector BoundToCube<span class="br0">(</span> <span class="kw4">FLOAT</span> Radius <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector
                <span class="br0">(</span>
                        <span class="kw7">Clamp</span><span class="br0">(</span>X,-Radius,Radius<span class="br0">)</span>,
                        <span class="kw7">Clamp</span><span class="br0">(</span>Y,-Radius,Radius<span class="br0">)</span>,
                        <span class="kw7">Clamp</span><span class="br0">(</span>Z,-Radius,Radius<span class="br0">)</span>
                <span class="br0">)</span>;
        <span class="br0">}</span>
        void AddBounded<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V, <span class="kw4">FLOAT</span> Radius=MAXSWORD <span class="br0">)</span>
        <span class="br0">{</span>
                *this = <span class="br0">(</span>*this + V<span class="br0">)</span>.<span class="me1">BoundToCube</span><span class="br0">(</span>Radius<span class="br0">)</span>;
        <span class="br0">}</span>
        FLOAT&amp; Component<span class="br0">(</span> <span class="kw4">INT</span> Index <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> <span class="br0">(</span>&amp;X<span class="br0">)</span><span class="br0">[</span>Index<span class="br0">]</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Return a boolean that is based on the vector's direction.</span>
        <span class="co1">// When      V==(0,0,0) Booleanize(0)=1.</span>
        <span class="co1">// Otherwise Booleanize(V) &lt;-&gt; !Booleanize(!B).</span>
        UBOOL Booleanize<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span>
                        X &gt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> :
                        X &lt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">0</span> :
                        Y &gt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> :
                        Y &lt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">0</span> :
                        Z &gt;= <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> : <span class="nu0">0</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Transformation.</span>
        FVector TransformVectorBy<span class="br0">(</span> <span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span> <span class="br0">)</span> <span class="kw5">const</span>;
        FVector TransformPointBy<span class="br0">(</span> <span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span> <span class="br0">)</span> <span class="kw5">const</span>;
        FVector MirrorByVector<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; MirrorNormal <span class="br0">)</span> <span class="kw5">const</span>;
        FVector MirrorByPlane<span class="br0">(</span> <span class="kw5">const</span> FPlane&amp; MirrorPlane <span class="br0">)</span> <span class="kw5">const</span>;
        FVector PivotTransform<span class="br0">(</span><span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span><span class="br0">)</span> <span class="kw5">const</span>;
 
        <span class="co1">// Complicated functions.</span>
        FRotator Rotation<span class="br0">(</span><span class="br0">)</span>;
        void FindBestAxisVectors<span class="br0">(</span> FVector&amp; Axis1, FVector&amp; Axis2 <span class="br0">)</span>;
        FVector SafeNormal<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>; <span class="co1">//warning: Not inline because of compiler bug.</span>
 
        <span class="co1">// Friends.</span>
        friend <span class="kw4">FLOAT</span> FDist<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V1, <span class="kw5">const</span> FVector&amp; V2 <span class="br0">)</span>;
        friend <span class="kw4">FLOAT</span> FDistSquared<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V1, <span class="kw5">const</span> FVector&amp; V2 <span class="br0">)</span>;
        friend UBOOL FPointsAreSame<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; P, <span class="kw5">const</span> FVector&amp; Q <span class="br0">)</span>;
        friend UBOOL FPointsAreNear<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw4">FLOAT</span> Dist<span class="br0">)</span>;
        friend <span class="kw4">FLOAT</span> FPointPlaneDist<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point, <span class="kw5">const</span> FVector&amp; PlaneBase, <span class="kw5">const</span> FVector&amp; PlaneNormal <span class="br0">)</span>;
        friend FVector FLinePlaneIntersection<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw5">const</span> FVector&amp; PlaneOrigin, <span class="kw5">const</span> FVector&amp; PlaneNormal <span class="br0">)</span>;
        friend FVector FLinePlaneIntersection<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw5">const</span> FPlane&amp; <span class="kw4">Plane</span> <span class="br0">)</span>;
        friend UBOOL FParallel<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Normal1, <span class="kw5">const</span> FVector&amp; Normal2 <span class="br0">)</span>;
        friend UBOOL FCoplanar<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Base1, <span class="kw5">const</span> FVector&amp; Normal1, <span class="kw5">const</span> FVector&amp; Base2, <span class="kw5">const</span> FVector&amp; Normal2 <span class="br0">)</span>;
 
        <span class="co1">// Serializer.</span>
        friend FArchive&amp; operator&lt;&lt;<span class="br0">(</span> FArchive&amp; Ar, FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> Ar &lt;&lt; V.<span class="me1">X</span> &lt;&lt; V.<span class="me1">Y</span> &lt;&lt; V.<span class="me1">Z</span>;
        <span class="br0">}</span>
 <span class="br0">}</span> GCC_ALIGN<span class="br0">(</span><span class="nu0">16</span><span class="br0">)</span>;
 
 
 
 <span class="kw2">#else</span>
 
 
 
 <span class="kw2">#define</span> FVECTOR_ALIGNMENT DEFAULT_ALIGNMENT
 <span class="kw5">class</span> CORE_API FVector 
 <span class="br0">{</span>
 public:
        <span class="co1">// Variables.</span>
        <span class="kw4">FLOAT</span> X,Y,Z;
 
        <span class="co1">// Constructors.</span>
        FVector<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span><span class="br0">}</span>
 
        FVector<span class="br0">(</span> <span class="kw4">FLOAT</span> InX, <span class="kw4">FLOAT</span> InY, <span class="kw4">FLOAT</span> InZ <span class="br0">)</span>
        :       X<span class="br0">(</span>InX<span class="br0">)</span>, Y<span class="br0">(</span>InY<span class="br0">)</span>, Z<span class="br0">(</span>InZ<span class="br0">)</span>
        <span class="br0">{</span><span class="br0">}</span>
 
        <span class="co1">// Binary math operators.</span>
        FVector <span class="kw6">operator</span>^<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector
                <span class="br0">(</span>
                        Y * V.<span class="me1">Z</span> - Z * V.<span class="me1">Y</span>,
                        Z * V.<span class="me1">X</span> - X * V.<span class="me1">Z</span>,
                        X * V.<span class="me1">Y</span> - Y * V.<span class="me1">X</span>
                <span class="br0">)</span>;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> operator|<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X*V.<span class="me1">X</span> + Y*V.<span class="me1">Y</span> + Z*V.<span class="me1">Z</span>;
        <span class="br0">}</span>
        friend FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span>, <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> V.<span class="me1">X</span> * <span class="kw4">Scale</span>, V.<span class="me1">Y</span> * <span class="kw4">Scale</span>, V.<span class="me1">Z</span> * <span class="kw4">Scale</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>+<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> X + V.<span class="me1">X</span>, Y + V.<span class="me1">Y</span>, Z + V.<span class="me1">Z</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector operator-<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> X - V.<span class="me1">X</span>, Y - V.<span class="me1">Y</span>, Z - V.<span class="me1">Z</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> X * <span class="kw4">Scale</span>, Y * <span class="kw4">Scale</span>, Z * <span class="kw4">Scale</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>/<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RScale = <span class="nu0">1</span>.<span class="me1">f</span>/<span class="kw4">Scale</span>;
                <span class="kw1">return</span> FVector<span class="br0">(</span> X * RScale, Y * RScale, Z * RScale <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>*<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> X * V.<span class="me1">X</span>, Y * V.<span class="me1">Y</span>, Z * V.<span class="me1">Z</span> <span class="br0">)</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Binary comparison operators.</span>
        UBOOL <span class="kw6">operator</span>==<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X==V.<span class="me1">X</span> &amp;&amp; Y==V.<span class="me1">Y</span> &amp;&amp; Z==V.<span class="me1">Z</span>;
        <span class="br0">}</span>
        UBOOL <span class="kw6">operator</span>!=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X!=V.<span class="me1">X</span> || Y!=V.<span class="me1">Y</span> || Z!=V.<span class="me1">Z</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Unary operators.</span>
        FVector operator-<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> -X, -Y, -Z <span class="br0">)</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Assignment operators.</span>
        FVector <span class="kw6">operator</span>+=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                X += V.<span class="me1">X</span>; Y += V.<span class="me1">Y</span>; Z += V.<span class="me1">Z</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector operator-=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                X -= V.<span class="me1">X</span>; Y -= V.<span class="me1">Y</span>; Z -= V.<span class="me1">Z</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>*=<span class="br0">(</span> <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> <span class="br0">)</span>
        <span class="br0">{</span>
                X *= <span class="kw4">Scale</span>; Y *= <span class="kw4">Scale</span>; Z *= <span class="kw4">Scale</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>/=<span class="br0">(</span> <span class="kw4">FLOAT</span> V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RV = <span class="nu0">1</span>.<span class="me1">f</span>/V;
                X *= RV; Y *= RV; Z *= RV;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>*=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                X *= V.<span class="me1">X</span>; Y *= V.<span class="me1">Y</span>; Z *= V.<span class="me1">Z</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
        FVector <span class="kw6">operator</span>/=<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                X /= V.<span class="me1">X</span>; Y /= V.<span class="me1">Y</span>; Z /= V.<span class="me1">Z</span>;
                <span class="kw1">return</span> *this;
        <span class="br0">}</span>
 
        <span class="co1">// Simple functions.</span>
        <span class="kw4">FLOAT</span> Size<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> appSqrt<span class="br0">(</span> X*X + Y*Y + Z*Z <span class="br0">)</span>;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> SizeSquared<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X*X + Y*Y + Z*Z;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> Size2D<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span> 
        <span class="br0">{</span>
                <span class="kw1">return</span> appSqrt<span class="br0">(</span> X*X + Y*Y <span class="br0">)</span>;
        <span class="br0">}</span>
        <span class="kw4">FLOAT</span> SizeSquared2D<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span> 
        <span class="br0">{</span>
                <span class="kw1">return</span> X*X + Y*Y;
        <span class="br0">}</span>
        <span class="kw4">int</span> IsNearlyZero<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span>
                                <span class="kw7">Abs</span><span class="br0">(</span>X<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER
                        &amp;&amp;      <span class="kw7">Abs</span><span class="br0">(</span>Y<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER
                        &amp;&amp;      <span class="kw7">Abs</span><span class="br0">(</span>Z<span class="br0">)</span>&lt;KINDA_SMALL_NUMBER;
        <span class="br0">}</span>
        UBOOL IsZero<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> X==<span class="nu0">0</span>.<span class="me1">f</span> &amp;&amp; Y==<span class="nu0">0</span>.<span class="me1">f</span> &amp;&amp; Z==<span class="nu0">0</span>.<span class="me1">f</span>;
        <span class="br0">}</span>
        UBOOL Normalize<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> SquareSum = X*X+Y*Y+Z*Z;
                <span class="kw1">if</span><span class="br0">(</span> SquareSum &gt;= SMALL_NUMBER <span class="br0">)</span>
                <span class="br0">{</span>
                        <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> = <span class="nu0">1</span>.<span class="me1">f</span>/appSqrt<span class="br0">(</span>SquareSum<span class="br0">)</span>;
                        X *= <span class="kw4">Scale</span>; Y *= <span class="kw4">Scale</span>; Z *= <span class="kw4">Scale</span>;
                        <span class="kw1">return</span> <span class="nu0">1</span>;
                <span class="br0">}</span>
                <span class="kw1">else</span> <span class="kw1">return</span> <span class="nu0">0</span>;
        <span class="br0">}</span>
        FVector Projection<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> RZ = <span class="nu0">1</span>.<span class="me1">f</span>/Z;
                <span class="kw1">return</span> FVector<span class="br0">(</span> X*RZ, Y*RZ, <span class="nu0">1</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector UnsafeNormal<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>
        <span class="br0">{</span>
                <span class="kw4">FLOAT</span> <span class="kw4">Scale</span> = <span class="nu0">1</span>.<span class="me1">f</span>/appSqrt<span class="br0">(</span>X*X+Y*Y+Z*Z<span class="br0">)</span>;
                <span class="kw1">return</span> FVector<span class="br0">(</span> X*<span class="kw4">Scale</span>, Y*<span class="kw4">Scale</span>, Z*<span class="kw4">Scale</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector GridSnap<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Grid <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector<span class="br0">(</span> FSnap<span class="br0">(</span>X, Grid.<span class="me1">X</span><span class="br0">)</span>,FSnap<span class="br0">(</span>Y, Grid.<span class="me1">Y</span><span class="br0">)</span>,FSnap<span class="br0">(</span>Z, Grid.<span class="me1">Z</span><span class="br0">)</span> <span class="br0">)</span>;
        <span class="br0">}</span>
        FVector BoundToCube<span class="br0">(</span> <span class="kw4">FLOAT</span> Radius <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> FVector
                <span class="br0">(</span>
                        <span class="kw7">Clamp</span><span class="br0">(</span>X,-Radius,Radius<span class="br0">)</span>,
                        <span class="kw7">Clamp</span><span class="br0">(</span>Y,-Radius,Radius<span class="br0">)</span>,
                        <span class="kw7">Clamp</span><span class="br0">(</span>Z,-Radius,Radius<span class="br0">)</span>
                <span class="br0">)</span>;
        <span class="br0">}</span>
        void AddBounded<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V, <span class="kw4">FLOAT</span> Radius=MAXSWORD <span class="br0">)</span>
        <span class="br0">{</span>
                *this = <span class="br0">(</span>*this + V<span class="br0">)</span>.<span class="me1">BoundToCube</span><span class="br0">(</span>Radius<span class="br0">)</span>;
        <span class="br0">}</span>
        FLOAT&amp; Component<span class="br0">(</span> <span class="kw4">INT</span> Index <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> <span class="br0">(</span>&amp;X<span class="br0">)</span><span class="br0">[</span>Index<span class="br0">]</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Return a boolean that is based on the vector's direction.</span>
        <span class="co1">// When      V==(0,0,0) Booleanize(0)=1.</span>
        <span class="co1">// Otherwise Booleanize(V) &lt;-&gt; !Booleanize(!B).</span>
        UBOOL Booleanize<span class="br0">(</span><span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span>
                        X &gt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> :
                        X &lt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">0</span> :
                        Y &gt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> :
                        Y &lt;  <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">0</span> :
                        Z &gt;= <span class="nu0">0</span>.<span class="me1">f</span> ? <span class="nu0">1</span> : <span class="nu0">0</span>;
        <span class="br0">}</span>
 
        <span class="co1">// Transformation.</span>
        FVector TransformVectorBy<span class="br0">(</span> <span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span> <span class="br0">)</span> <span class="kw5">const</span>;
        FVector TransformPointBy<span class="br0">(</span> <span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span> <span class="br0">)</span> <span class="kw5">const</span>;
        FVector MirrorByVector<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; MirrorNormal <span class="br0">)</span> <span class="kw5">const</span>;
        FVector MirrorByPlane<span class="br0">(</span> <span class="kw5">const</span> FPlane&amp; MirrorPlane <span class="br0">)</span> <span class="kw5">const</span>;
        FVector PivotTransform<span class="br0">(</span><span class="kw5">const</span> FCoords&amp; <span class="kw4">Coords</span><span class="br0">)</span> <span class="kw5">const</span>;
 
        <span class="co1">// Complicated functions.</span>
        FRotator Rotation<span class="br0">(</span><span class="br0">)</span>;
        void FindBestAxisVectors<span class="br0">(</span> FVector&amp; Axis1, FVector&amp; Axis2 <span class="br0">)</span>;
        FVector SafeNormal<span class="br0">(</span><span class="br0">)</span> <span class="kw5">const</span>; <span class="co1">//warning: Not inline because of compiler bug.</span>
 
        <span class="co1">// Friends.</span>
        friend <span class="kw4">FLOAT</span> FDist<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V1, <span class="kw5">const</span> FVector&amp; V2 <span class="br0">)</span>;
        friend <span class="kw4">FLOAT</span> FDistSquared<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; V1, <span class="kw5">const</span> FVector&amp; V2 <span class="br0">)</span>;
        friend UBOOL FPointsAreSame<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; P, <span class="kw5">const</span> FVector&amp; Q <span class="br0">)</span>;
        friend UBOOL FPointsAreNear<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw4">FLOAT</span> Dist<span class="br0">)</span>;
        friend <span class="kw4">FLOAT</span> FPointPlaneDist<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point, <span class="kw5">const</span> FVector&amp; PlaneBase, <span class="kw5">const</span> FVector&amp; PlaneNormal <span class="br0">)</span>;
        friend FVector FLinePlaneIntersection<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw5">const</span> FVector&amp; PlaneOrigin, <span class="kw5">const</span> FVector&amp; PlaneNormal <span class="br0">)</span>;
        friend FVector FLinePlaneIntersection<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Point1, <span class="kw5">const</span> FVector&amp; Point2, <span class="kw5">const</span> FPlane&amp; <span class="kw4">Plane</span> <span class="br0">)</span>;
        friend UBOOL FParallel<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Normal1, <span class="kw5">const</span> FVector&amp; Normal2 <span class="br0">)</span>;
        friend UBOOL FCoplanar<span class="br0">(</span> <span class="kw5">const</span> FVector&amp; Base1, <span class="kw5">const</span> FVector&amp; Normal1, <span class="kw5">const</span> FVector&amp; Base2, <span class="kw5">const</span> FVector&amp; Normal2 <span class="br0">)</span>;
 
        <span class="co1">// Serializer.</span>
        friend FArchive&amp; operator&lt;&lt;<span class="br0">(</span> FArchive&amp; Ar, FVector&amp; V <span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">return</span> Ar &lt;&lt; V.<span class="me1">X</span> &lt;&lt; V.<span class="me1">Y</span> &lt;&lt; V.<span class="me1">Z</span>;
        <span class="br0">}</span>
 <span class="br0">}</span>;
 <span class="kw2">#endif</span>
</pre></div>
<hr />
<p><b>DJPaul:</b> Interesting page, rubbish on itself. What about we make a new page that we can put this - and other notes about the Unreal Engine's Native Classes we've gotten out of Epic? Perhaps hack0rz <a href="../../../../articles/n/a/t/Legacy%7ENative_Coding_1c24.html" title="Legacy:Native Coding">Native Coding</a> around a bit.</p>
<p>That way we can link to this, the few UT2003 native classes we've gotten out of epic via ut2003mods, the Deus Ex native sources, etc.</p>
<p><b>Tarquin:</b> What is this page?</p>

<!-- 
NewPP limit report
Preprocessor node count: 13/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
#ifexist count: 0/100
-->
<div class="printfooter">
</div>
	    	    <!-- end content -->
	    <div class="visualClear"></div>
	  </div>
	</div>
      </div>
      <div id="column-one">
	<div id="p-cactions" class="portlet">
	  <h5>Views</h5>
	  <ul>
	    <li id="ca-nstab-legacy"
	       class="selected"	       ><a href="../../../../articles/o/f/f/Legacy%7EOfficial_UnMath_Page_b5e1.html">Legacy</a></li><li id="ca-talk"
	       class="new"	       ><a href="../../../../articles/o/f/f/Legacy_talk%7EOfficial_UnMath_Page_f10c.html">Discussion</a></li><li id="ca-current"
	       	       ><a href="http://wiki.beyondunreal.com/Legacy:Official_UnMath_Page">Current revision</a></li>	  </ul>
	</div>
	<div class="portlet" id="p-logo">
	  <a style="background-image: url(../../../../misc/uewiki.png);"
	    href="../../../../index.html"
	    title="Main Page"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
	  <h5>Navigation</h5>
	  <div class='pBody'>
	    <ul>
	    	      <li id="n-mainpage"><a href="../../../../index.html">Main Page</a></li>
	     	      <li id="n-portal"><a href="../../../../articles/c/o/m/Unreal_Wiki%7ECommunity_Portal_3311.html">Community portal</a></li>
	     	      <li id="n-help"><a href="../../../../articles/c/o/n/Help%7EContents_22de.html">Help</a></li>
	     	    </ul>
	  </div>
	</div>
		<div id="p-search" class="portlet">
	  <h5><label for="searchInput">Search</label></h5>
	  <div id="searchBody" class="pBody">
	    <form action="javascript:goToStatic(3)" id="searchform"><div>
	      <input id="searchInput" name="search" type="text"
	        accesskey="f" value="" />
	      <input type='submit' name="go" class="searchButton" id="searchGoButton"
	        value="Go" />
	    </div></form>
	  </div>
	</div>
	      </div><!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer">
    <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="../../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>	<div id="f-copyrightico"><a href="../../../../../COPYING.html"><img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" alt='Attribution-Noncommercial-Share Alike 3.0' /></a></div>	<ul id="f-list">
	  	  	  <li id="f-credits">This page was last modified 22:44, 14 February 2004 by <a href="../../../../articles/t/a/r/User%7ETarquin_cdb6.html" title="User:Tarquin">tarquin</a>. Based on work by Anonymous user(s) of Unreal Wiki.</li>	  <li id="f-copyright">Licensed as <a href="../../../../articles/c/o/p/Unreal_Wiki%7ECopyrights_e561.html" title="Unreal Wiki:Copyrights">Attribution-Noncommercial-Share Alike 3.0</a>.</li>	  <li id="f-about"><a href="../../../../articles/a/b/o/Unreal_Wiki%7EAbout_9ce6.html" title="Unreal Wiki:About">About Unreal Wiki</a></li>	  <li id="f-disclaimer"><a href="../../../../articles/g/e/n/Unreal_Wiki%7EGeneral_disclaimer_a0a2.html" title="Unreal Wiki:General disclaimer">Disclaimers</a></li>	  	</ul>
      </div>
    </div>
  </body>
</html>
